\subsection{Architectural Overview}
The system is built on a clientâ€“server architecture, separating concerns between a \textbf{React frontend} and an \textbf{Express backend}. This modular design ensures that each component can operate, scale, and be maintained independently. The backend manages business logic and database interactions, while the frontend is responsible for presenting information and capturing user interaction. Communication between the two layers occurs exclusively via RESTful API calls, maintaining a strict separation of concerns and minimizing coupling.

\subsection{Evaluation of Key Architectural Aspects}

\textbf{Logical Separation:} The frontend and backend are completely decoupled; the frontend has no direct access to backend logic or databases.

\textbf{Communication (API):} All interactions occur via RESTful APIs, preserving a stateless design and enabling consistent decoupling.

\textbf{Security:} Authentication and authorization are handled server-side. The frontend never handles sensitive logic or has direct access to user data.

\textbf{Responsibility Split:} The client manages rendering and local UI state; the server handles data validation, persistence, and all core processing.

\subsection{Strengths}
\begin{itemize}
    \item \textbf{Scalability}: The backend can be scaled independently (e.g., through load balancing), while the frontend is lightweight and can be served statically.
    \item \textbf{Maintainability}: Clear separation of concerns allows UI changes without backend modifications and vice versa, improving long-term maintainability.
    \item \textbf{Flexibility}: The system architecture supports multiple types of clients using the same backend API.
    \item \textbf{Security}: By centralizing sensitive operations on the server, the system reduces exposure to potential vulnerabilities.
\end{itemize}

\subsection{Limitations}
\begin{itemize}
    \item \textbf{Database Integration}: Local databases are currently in use, limiting centralization and real-time synchronization between users.
    \item \textbf{Feature Scope}: Some intended features remain unimplemented due to time constraints; future iterations could further enhance system capability.
    \item \textbf{User Interface}: Functionality was prioritized over visual design, resulting in a utilitarian UI that could benefit from aesthetic improvements.
\end{itemize}

\subsection{Alignment with Project Goals}

\begin{table}[H]
\centering
\noindent\begin{tabularx}{\linewidth}{|l|X|}
\hline
\textbf{Goal} & \textbf{Implementation} \\
\hline
Sustainable Study Habits & The server enforces daily point caps to promote consistent, healthy engagement patterns. \\
\hline
Gamification and Rewards & The client displays avatars and themes based on reward data retrieved from the backend. \\
\hline
Scalability & The architecture supports increasing user loads without compromising client performance. \\
\hline
Educational Feedback & The server aggregates and processes user performance data; the client renders this feedback to users. \\
\hline
\end{tabularx}
\caption{Project Goals and Architectural Alignment}
\end{table}

\subsection{Unit Testing}
Unite Testing was used to ensure the reliability of the system. In particular, we used \textbf{Jest}, which is a popular JavaScript testing framework. The test are found in the aptly named \texttt{\_\_test\_\_} folder inside the \texttt{study-app} section of the repository. The test cover the major components of the GUI, including:
\begin{itemize}
    \item \textbf{Authentication}: Tests ensure that the authentication process works as expected, including login functionality, sign up processes, and error handling.
    \item \textbf{Classes}: Tests ensure that classes are displayed properly, with the GUI reflecting the correct data from the backend and differentiating between students and teachers.
    \item \textbf{Class Creation}: Tests ensure that the class creation process works as expected, with classes having a name, subject, and daily point cap.
    \item \textbf{Class Overview}: Tests ensure that the proper classes are shown to the user and that teachers have the ability to create new classes.
    \item \textbf{Quiz Creation}: Tests ensure that the quiz creation process properly validates quiz titles, release/due dates, questions, and answers.
    \item \textbf{Quiz Taking}: Tests ensure that the quiz taking process works as expected, including question display, answer selection, and score calculation.
    \item \textbf{Shop}: Tests ensure that the shop displays the correct items and that the purchase process works as expected.
\end{itemize}

The tests are run using the command \texttt{npm test} while the user is in the \texttt{study-app} directory. The tests are designed to be run in a continuous integration environment, ensuring that any changes to the codebase do not break existing functionality. The tests are also designed to be easy to read and understand, making it easy for other developers to contribute to the project.